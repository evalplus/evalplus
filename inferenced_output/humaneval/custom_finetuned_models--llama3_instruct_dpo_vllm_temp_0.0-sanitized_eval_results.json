{"date": "2024-08-09 15:34", "hash": "fe585eb4df8c88d844eeb463ea4d0302", "eval": {"HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring \"\"\"\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if string == string[::-1]:  # If the string is already a palindrome, return it\n        return string\n    for i in range(len(string)):\n        if string[:i+1] == string[:i+1][::-1]:  # Find the longest postfix of supplied string that is a palindrome\n            return string + string[:i][::-1]  # Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return string  # If no palindrome is found, return the original string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["xyz"]], "plus_fail_tests": [["race"]]}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    max_depth = 0\n    current_depth = 0\n    temp = \"\"\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            temp += char\n            if current_depth > max_depth:\n                max_depth = current_depth\n        elif char == ')':\n            current_depth -= 1\n            temp += char\n            if current_depth == 0:\n                result.append(max_depth)\n                max_depth = 0\n                temp = \"\"\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["(())(()())"]]}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.extend([delimeter, num])\n    return result if len(numbers) > 0 else []", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[], 7]], "plus_fail_tests": [[[], 2]]}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of float numbers\n\n    Returns:\n        float: Mean Absolute Deviation\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    \n    return mad", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n    total_sum = 0\n    total_product = 1\n    \n    for num in numbers:\n        total_sum += num\n        total_product *= num\n    \n    return total_sum, total_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    temp = \"\"\n    for char in paren_string:\n        if char == \"(\":\n            temp += char\n        elif char == \")\":\n            temp += char\n            if temp.count(\"(\") == temp.count(\")\"):\n                result.append(temp)\n                temp = \"\"\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(num, result[-1]))\n    return result", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[]]], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    \"\"\"Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    \"\"\"\n    # Check if both strings have the same length\n    if len(a) != len(b):\n        raise ValueError(\"Both strings must have the same length\")\n\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over the characters in the strings\n    for char_a, char_b in zip(a, b):\n        # Perform binary XOR operation\n        if char_a == char_b:\n            result += '0'\n        else:\n            result += '1'\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string \"\"\"\n    return [string[:i] for i in range(1, len(string)+1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Return a greatest common divisor of two integers a and b\"\"\"\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return abs(a)\n    return gcd(abs(a), abs(b))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\ndef parse_music(music_string: str) -> List[int]:\n    music_list = music_string.replace(' ', '').split('|')\n    beats = [4 if note == 'o' else 2 if note == 'o|' else 1 for note in music_list]\n    return beats", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [["o o| o| o|"]]}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\ndef factorize(n: int) -> List[int]:\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n    if n > 1:\n        factors.append(n)\n    return factors", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[10]]}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\ndef sort_numbers(numbers: str) -> str:\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    nums = [num for num in numbers.split() if num in num_dict]\n    nums.sort(key=lambda x: num_dict[x])\n    return ' '.join(nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4, 4]]]}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers \"\"\"\n    return [value for value in values if isinstance(value, int)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Find how many times a given substring can be found in the original string. Count overlapping cases.\"\"\"\n    count = start = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos != -1:\n            start = pos + 1\n            count += 1\n        else:\n            break\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.lower()))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    \"\"\"Return length of given string\"\"\"\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "def get_positive(l: list):\n    return [num for num in l if num > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string\"\"\"\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n    \n    return closest_pair", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1.0, 2.0, 5.9, 4.0, 5.0]]], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "def flip_case(string: str) -> str:\n    return ''.join(char.upper() if char.islower() else char.lower() for char in string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "def sort_even(l: list):\n    return [x if i % 2 == 0 else x for i, x in enumerate(sorted([x for i, x in enumerate(l) if i % 2 == 0], reverse=True))]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3]]], "plus_fail_tests": [[[2, 6, 4, 8, 10]]]}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    for i in range(77, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[78]], "plus_fail_tests": [[78]]}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\nimport numpy as np\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees a solution.\n    \"\"\"\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if abs(xs[0]) > max(abs(x) for x in xs[1:]):\n        return -xs[0] / xs[1]\n    elif abs(xs[-1]) > max(abs(x) for x in xs[:-1]):\n        return -1\n    else:\n        def f(x):\n            return poly(xs, x)\n        def df(x):\n            return sum([i * xs[i] * math.pow(x, i-1) for i in range(1, len(xs))])\n        x0 = 1\n        for _ in range(1000):\n            x1 = x0 - f(x0) / df(x0)\n            if abs(x1 - x0) < 1e-6:\n                return round(x1, 2)\n            x0 = x1\n        return round(x0, 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-10, -2]]], "plus_fail_tests": [[[5, 10, -3, 1]]]}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "def unique(l: list):\n    return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    result = \"\"\n    i = 0\n    while i < len(s):\n        if i + 2 < len(s):\n            result += s[i:i+3][1:] + s[i:i+3][0]\n        else:\n            result += s[i:]\n        i += 3\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["uzfplzjfzcltmdly"]], "plus_fail_tests": [["abcdefghijk"]]}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "def sort_third(l: list):\n    return [x if i % 3 != 0 else sorted([x for x in l if i % 3 == 0])[0] if i % 3 != 0 and i != 0 else l[0] for i, x in enumerate(l)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]]], "plus_fail_tests": [[[9, 12, 15, 6, 3, 8, 10, 23, 7]]]}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "def max_element(l: list):\n    return max(l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    This function calculates the number of collisions between two sets of n cars moving in opposite directions.\n    \n    Parameters:\n    n (int): The number of cars in each set.\n    \n    Returns:\n    int: The number of collisions.\n    \"\"\"\n    return n * (n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list):\n    l = set(l)  # remove duplicates\n    for i in l:\n        for j in l:\n            if i != j:\n                if i + j in l:\n                    return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 0]]], "plus_fail_tests": [[[0, 0, 0]]]}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "def prime_fib(n: int):\n    def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    a, b = 2, 1\n    count = 1\n    while True:\n        a, b = b, a + b\n        if is_prime(b):\n            if count == n:\n                return b\n            count += 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[11]]}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int):\n    convertString = \"0123456789\"\n    if x < base:\n        return str(x)\n    else:\n        result = \"\"\n        while x > 0:\n            result = convertString[x % base] + result\n            x = x // base\n        return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "def incr_list(l: list):\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "def fib4(n: int):\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    elif n == 4:\n        return 2\n    else:\n        fib4_sequence = [0, 0, 2, 2]\n        for i in range(4, n):\n            fib4_sequence.append(fib4_sequence[i-1] + fib4_sequence[i-2] + fib4_sequence[i-3] + fib4_sequence[i-4])\n        return fib4_sequence[n-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[7]]}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26 + 25 - 5) % 26 + ord(\"a\")) if ch.isalpha() and ch.islower() else ch for ch in s])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["tantywccpjkimslotpzs"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    return text == text[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int):\n    return all(i < t for i in l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "def median(l: list):\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "def fib(n: int):\n    if n <= 0:\n        return \"Input should be a positive integer.\"\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str):\n    return sorted(s0) == sorted(s1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["eabcdzzzz", "dddzzzzzzzddeddabc"]], "plus_fail_tests": [["aaabbbccc", "abbabcbc"]]}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "def monotonic(l: list):\n    return all(l[i] <= l[i+1] for i in range(len(l)-1)) or all(l[i] >= l[i+1] for i in range(len(l)-1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(\"<\")\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return not stack", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "def search(lst):\n    frequency_dict = {}\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    max_num = -1\n    for num, freq in frequency_dict.items():\n        if num > 0 and freq >= num:\n            max_num = num\n    return max_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 1, 4, 1, 4, 4]]], "plus_fail_tests": [[[5, 5, 3, 4, 3, 5, 5, 5, 3]]]}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "def triangle_area(a, b, c):\n    sides = sorted([a, b, c])\n    if sides[0] + sides[1] <= sides[2]:\n        return -1\n    s = (sides[0] + sides[1] + sides[2]) / 2\n    return round((s * (s - sides[0]) * (s - sides[1]) * (s - sides[2])) ** 0.5, 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    x = str(x)\n    shift = shift % len(x)\n    return x[-shift:] + x[:-shift]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[97, 8]], "plus_fail_tests": [[1234, 6]]}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) == 0 or stack.pop() != \"(\":\n                return False\n    return len(stack) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    if not lst:\n        return []\n    sorted_lst = sorted(lst)\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))\n        if sorted_lst:\n            result.append(sorted_lst.pop())\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "def fibfib(n: int):\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b\n        return c", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[20]]}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    even_nodes = [(x, i) for i, x in enumerate(arr) if x % 2 == 0]\n    if not even_nodes:\n        return []\n    return [even_nodes[0][0], even_nodes[0][1]]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 2, 3]]], "plus_fail_tests": [[[7, 15, 12, 21, 8, 13]]]}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "def derivative(xs: list):\n    return [x * i for i, x in enumerate(xs[1:], 1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    return q == q[::-1] and sum(q) <= w", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    s = s.lower()  # convert to lowercase for simplicity\n    vowels = 'aeiou'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n        elif char == 'y' and s.endswith(char):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["aeiouyaeiouy"]]}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    left, right = 0, len(arr) - 1\n    changes = 0\n    while left < right:\n        if arr[left] != arr[right]:\n            if left + 1 < right:\n                if arr[left + 1] == arr[right]:\n                    arr[left + 1], arr[left] = arr[left], arr[left + 1]\n                    left += 1\n                else:\n                    arr[right], arr[left] = arr[left], arr[right]\n                    right -= 1\n                    changes += 1\n            else:\n                arr[right], arr[left] = arr[left], arr[right]\n                right -= 1\n                changes += 1\n        else:\n            left += 1\n            right -= 1\n    return changes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 5, 4, 7, 9, 6]]], "plus_fail_tests": [[[1, 2, 3, 4, 5]]]}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(num):\n        factors = []\n        for i in range(2, num + 1):\n            while num % i == 0 and is_prime(i):\n                factors.append(i)\n                num //= i\n        return factors\n\n    factors = prime_factors(n)\n    return len(factors) == 3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] in s[i+1:i+4]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["xyy"]], "plus_fail_tests": [["abcabc"]]}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    count = 0\n    for char in num:\n        if char in '237BD':\n            if is_prime(int(char, 16)):\n                count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["123456789ABCDEF0"]], "plus_fail_tests": [["753BD"]]}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "def is_simple_power(x, n):\n    import math\n    if x < 1:\n        return False\n    if n < 1:\n        return False\n    if x == 1:\n        return True\n    if n == 1:\n        return False\n    if x == n:\n        return True\n    if x % n != 0:\n        return False\n    i = 0\n    while x > 1:\n        if x % n != 0:\n            return False\n        x = x // n\n        i += 1\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-2, -2]]}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "def iscube(a):\n    c = int(a**0.3333333333333333)\n    return c*c*c == a", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[-1]], "plus_fail_tests": [[-8]]}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    letter_grades = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-', 'E']\n    grade_boundaries = [4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7, 0.0]\n    return [letter_grades[0] if g >= grade_boundaries[0] else letter_grades[i] for i in range(len(grade_boundaries) - 1) if g >= grade_boundaries[i] and g < grade_boundaries[i + 1] for g in grades]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": [[[3.8, 2.5, 3.9, 2.2, 1.0]]]}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    return lst1 if count_chars(lst1) <= count_chars(lst2) else lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "def solve(N):\n    return bin(N).replace(\"0b\", \"\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1000]], "plus_fail_tests": [[10]]}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "def prime_length(string):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int):\n    return sum(range(1, n + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int):\n    def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    max_factor = 1\n    for i in range(n, 1, -1):\n        if n % i == 0 and is_prime(i):\n            max_factor = i\n            break\n    return max_factor", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "def encode(message):\n    result = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.isupper():\n                if char == 'A' or char == 'E' or char == 'I' or char == 'O' or char == 'U':\n                    result += chr((ord(char) - 65 + 2) % 26 + 65)\n                else:\n                    result += chr((ord(char) - 65 + 1) % 26 + 65)\n            else:\n                if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n                    result += chr((ord(char) - 97 + 2) % 26 + 97)\n                else:\n                    result += chr((ord(char) - 97 + 1) % 26 + 97)\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    S = S.replace('.', '. ').replace('?', '? ').replace('!', '! ')\n    sentences = S.split()\n    boredoms = [i for i in range(len(sentences)) if sentences[i].lower() == 'i']\n    return len(boredoms) if boredoms else 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["You and I are going for a walk"]], "plus_fail_tests": [["I forgot my phone in the car. Oh no, now I have to go back and get it."]]}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    try:\n        lst = sorted(set(lst))\n        if len(lst) < 2:\n            return None\n        return lst[1]\n    except TypeError:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(dict):\n    if not dict:\n        return False\n    all_lower = all(isinstance(key, str) and key.islower() for key in dict)\n    all_upper = all(isinstance(key, str) and key.isupper() for key in dict)\n    return all_lower or all_upper", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        return False\n    return (x == y + z or x == z + y or y == x + z)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[-4, 6, 2]], "plus_fail_tests": [[-1, 8, 7]]}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    if not array:\n        return array\n    if len(array) == 1:\n        return array\n    if sum(array[0:1]) % 2 == 0:\n        return sorted(array, reverse=False)\n    else:\n        return sorted(array, reverse=True)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 4, 3, 0, 1, 5, 6]]], "plus_fail_tests": [[[1, 2, 3, 4]]]}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    try:\n        value = float(value)\n    except ValueError:\n        return \"Invalid input. Please enter a number.\"\n    if value == int(value):\n        return int(value)\n    if value > 0:\n        return int(round(value))\n    else:\n        return int(round(value)) if round(value) != 0 else 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["14.5"]], "plus_fail_tests": [["-6.5"]]}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    count = 0\n    vowels = 'AEIOU'\n    for i in range(0, len(s)):\n        if i % 2 == 0 and s[i].upper() in vowels:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["aBCdEf"]], "plus_fail_tests": [["abcDEf"]]}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    return (a % 10) * (b % 10)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-6, -9]]}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    result = []\n    i = n\n    while n > 0:\n        result.append(i)\n        if i % 2 == 0:\n            i += 1\n        else:\n            i += 2\n        n -= 1\n    return result[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[2]]}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    return [word.strip() for word in s.replace(\",\", \" \").split()]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    if x > y:\n        x, y = y, x\n    if x % 2 == 0:\n        return x\n    for i in range(x + 1, y + 1):\n        if i % 2 == 0:\n            return i\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12, 15]], "plus_fail_tests": [[20, 30]]}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    if not arr:\n        return True\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": [[[5, 6, 7, 8, 1, 2, 3, 4]]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    return sum(1 for num in map(abs, arr) if num > 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    avg = (n + m) // 2 + (1 if (n + m) % 2 else 0)\n    return bin(avg)[2:].zfill((avg.bit_length() + 1) if avg != 0 else 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 5]], "plus_fail_tests": [[1, 1]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    odd_count = sum(1 for x in lst1 if x % 2 != 0)\n    return \"YES\" if odd_count == 0 else \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4], [1, 2, 3, 4]]], "plus_fail_tests": [[[1, 3, 5], [2, 4, 6]]]}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    if not test:\n        return {}\n    test = test.split()\n    freq = {}\n    for char in test:\n        if char:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n    max_count = max(freq.values())\n    max_chars = [k for k, v in freq.items() if v == max_count]\n    return {k: v for k, v in freq.items() if v == max_count}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    num_dict = {1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    return [num_dict[i] for i in sorted([i for i in arr if 1 <= i <= 9], reverse=True)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return even_count, odd_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    def has_even_digit(n):\n        return any(int(digit) % 2 == 0 for digit in str(n))\n\n    return sorted([num for num in x if not has_even_digit(num)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    result = []\n    for i in range(2, n):\n        if is_prime(i):\n            result.append(i)\n        if i >= n:\n            break\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "def f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(1 if i == 1 else eval('*'.join(map(str, range(2, i + 1))))\n            )\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, 1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {str(count)}n the str{str(i)}ng {str(i)} of the {str(i)}nput.\")\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["1234567"]]], "plus_fail_tests": [[["2468"]]]}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s,c):\n    result = ''.join([i for i in s if i not in c])\n    return result, result == result[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = min(current_sum + num, num)\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum if min_sum != float('inf') else 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "def max_fill(grid, capacity):\n    total_water = sum(sum(row) for row in grid)\n    return -(-total_water // capacity)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 1, 1, 1], [1, 1, 1, 1]], 9]], "plus_fail_tests": [[[[1, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]], 2]]}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, -1, -1):\n        if word[i] in vowels:\n            return word[i]\n    return \"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["easy"]], "plus_fail_tests": [["alb"]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    stack = []\n    for char in lst[0] + lst[1]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[")())", "(()()("]]], "plus_fail_tests": [[[")()()()(()()))", "(("]]]}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if 10 > abs(x) >= 1)\narr = [111,21,3,4000,5,6,7,8,9]\nk = 4", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[11, 21, 3, 90, 5, 6, 7, 8, 9], 4]], "plus_fail_tests": [[[98, 87, 76, 65, 54, 43, 32, 21, 10], 5]]}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    s = s.split()\n    result = []\n    for word in s:\n        consonants = 0\n        for char in word:\n            if char.lower() not in 'aeiou':\n                consonants += 1\n        if consonants == n:\n            result.append(word)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    return sum(i for i in lst if i % 2 != 0 and (lst.index(i) % 2 == 0))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 3, 3, 3, 3]]], "plus_fail_tests": [[[1, 1, 1, 1, 1, 1]]]}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    def collatz_sequence(num):\n        sequence = [num]\n        while num != 1:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = num * 3 + 1\n            sequence.append(num)\n        return [x for x in sequence if x % 2 != 0]\n\n    return sorted(set(get_odd_collatz_helper(n)))\ndef get_odd_collatz_helper(n):\n    def collatz_sequence(num):\n        sequence = [num]\n        while num != 1:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = num * 3 + 1\n            sequence.append(num)\n        return sequence\n\n    return [x for x in collatz_sequence(n) if x % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "def valid_date(date):\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            if day < 1 or day > 31:\n                return False\n        elif month in [4, 6, 9, 11]:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            if day < 1 or day > 29:\n                return False\n        return True\n    except ValueError:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["06-04-202"]]}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)) and len(set(lst)) == len(lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    words = txt.split()\n    if len(words) > 0 and words[0].isalpha():\n        return words\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if ord(c) - ord('a') >= 0 and (ord(c) - ord('a')) % 2 != 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello,Hello,world !"]], "plus_fail_tests": [["apple, banana, orange, grapefruit"]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    if not arr:\n        return None\n    sign = 1\n    magnitude_sum = 0\n    for num in arr:\n        if num < 0:\n            sign *= -1\n        elif num > 0:\n            magnitude_sum += num\n        else:\n            magnitude_sum += num\n    return sign * magnitude_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, -4]]], "plus_fail_tests": [[[-1, -2, -2, -4]]]}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "def intersection(interval1, interval2):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n\n    if intersection_start > intersection_end:\n        return \"NO\"\n\n    intersection_length = intersection_end - intersection_start + 1\n\n    if intersection_length <= 1:\n        return \"NO\"\n\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "def minPath(grid, k):\n    def dfs(i, j, path, visited, k):\n        if k == 0:\n            return path\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited:\n                visited.add((ni, nj))\n                new_path = path + [grid[ni][nj]]\n                res = dfs(ni, nj, new_path, visited, k - 1)\n                if res:\n                    return res\n                visited.remove((ni, nj))\n        return None\n\n    min_path = float('inf')\n    res = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            visited = set([(i, j)])\n            path = [grid[i][j]]\n            temp = dfs(i, j, path, visited, k - 1)\n            if temp and len(temp) == k and (res is None or temp < res):\n                res = temp\n    return res", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9]]}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    count = 0\n    # Count numbers that start with 1\n    for i in range(10**(n-1), 10**n):\n        if str(i)[0] == '1':\n            count += 1\n    # Count numbers that end with 1\n    for i in range(10**(n-1), 10**n):\n        if str(i)[(-1)] == '1':\n            count += 1\n    # Subtract duplicates (numbers that both start and end with 1)\n    if n > 1:\n        count -= len([i for i in range(10**(n-1), 10**n) if str(i)[0] == '1' and str(i)[(-1)] == '1'])\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[10]]}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    if not isinstance(file_name, str):\n        return 'No'\n    if not file_name[0].isalpha() and file_name[0].isdigit():\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    if file_name.split('.')[1].lower() not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if file_name.count('0') > 3 or file_name.count('1') > 3 or file_name.count('2') > 3 or file_name.count('3') > 3 or file_name.count('4') > 3 or file_name.count('5') > 3 or file_name.count('6') > 3 or file_name.count('7') > 3 or file_name.count('8') > 3 or file_name.count('9') > 3:\n        return 'No'\n    return 'Yes'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["His12FILE94.exe"]], "plus_fail_tests": [[".exe"]]}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    negative = [x for x in lst if x < 0]\n    positive = [x for x in lst if x > 0]\n    \n    if not negative and not positive:\n        return None, None\n    elif not negative:\n        return None, min(positive) if positive else None\n    elif not positive:\n        return min(negative), None\n    else:\n        return min(negative), min(positive)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -3, -5, -6]]], "plus_fail_tests": [[[9, -4, -6, 5, 0, -2]]]}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0 and i != 0:\n            total += lst[i]**2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i]**3\n        else:\n            total += lst[i]\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -1, -1, -1, -1, -1, -1, -1, -1]]], "plus_fail_tests": [[[2, 4, 6, 8, 10, 12]]]}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    if isinstance(a, str) and isinstance(b, (int or float)):\n        b = str(b)\n    elif isinstance(b, str) and isinstance(a, (int or float)):\n        a = str(a)\n    if a == b:\n        return None\n    elif isinstance(a, str):\n        a = a.replace(\",\", \"\")\n        if \".\" in a:\n            a = float(a)\n        else:\n            a = int(a)\n    elif isinstance(b, str):\n        b = b.replace(\",\", \"\")\n        if \".\" in b:\n            b = float(b)\n        else:\n            b = int(b)\n    return a if a > b else b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, "2,3"]], "plus_fail_tests": [[10, "10.0"]]}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    if txt[-1].isalpha() and txt[-1] != ' ':\n        return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["apple"]], "plus_fail_tests": [["pUMPKIN PIE"]]}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    for a in range(2, n+1, 2):\n        for b in range(2, (n-a)//2+1, 2):\n            for c in range(2, (n-a-b)//2+1, 2):\n                for d in range(2, (n-a-b-c)//2+1, 2):\n                    if a + b + c + d == n:\n                        return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[20]]}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "def words_in_sentence(sentence):\n    result = \"\"\n    words = sentence.split()\n    for word in words:\n        if len(word) > 1 and all(word[i] != word[i - 1] for i in range(1, len(word))):\n            if all(1 != int(i) or i > len(word) // 2 for i in range(2, int(len(word) ** 0.5) + 1)):\n                result += word + \" \"\n    return result.strip()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["This is a test"]], "plus_fail_tests": [["cats and dogs"]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    return text.replace(\"  \", \"-\").replace(\" \", \"_\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Yellow Yellow  Dirty  Fellow"]], "plus_fail_tests": [["Hello,   world!"]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i-1] <= arr[i]:\n            return i-1\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 2, 3, 4, 5]]]}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "def digits(n):\n    product = 1\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2468]], "plus_fail_tests": [[246]]}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "def is_nested(s):\n    stack = []\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return bool(stack)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[[]]"]], "plus_fail_tests": [["[[]][]"]]}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "def sum_squares(lst):\n    return sum(int(i) ** 2 for i in (round(x) for x in lst))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.4, 4.2, 0]]], "plus_fail_tests": [[[0, 3.3, 7.7, -2.2]]]}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    return sorted((x for x in nums), key=lambda x: (sum(int(digit) for digit in str(abs(x))), -nums.index(x)) if nums else [])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 11, -1, -11, -12]]], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    x_num, x_den = map(int, map(int, x.split('/')))\n    n_num, n_den = map(int, map(int, n.split('/')))\n    \n    return x_num * n_den * n_num == x_den * n_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1/5", "5/1"]], "plus_fail_tests": [["3/4", "4/3"]]}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    def extension_strength(ext):\n        return sum(1 for c in ext if c.isupper()) - sum(1 for c in ext if c.islower())\n\n    return f\"{class_name}.{max(extensions, key=extension_strength)}\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    for i in range(len(b)):\n        if b in a[i:] + a[:i]:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["efef", "fee"]], "plus_fail_tests": [["banana", "nab"]]}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    result = tuple(planets[index1+1:index2])\n    if index1 > index2:\n        result = tuple(planets[index1:] + planets[:index2])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Earth", "Mercury"]], "plus_fail_tests": [["Neptune", "Mercury"]]}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if is_prime(n):\n        return x\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    return sum([i**2 for i in lst if isinstance(i, int) and i % 2 != 0 and i >= 0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    return sorted([x for x in lst if len(x) % 2 == 0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["aaaa", "bbbb", "dd", "cc"]]], "plus_fail_tests": [[["programming", "python", "java", "ruby"]]]}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    num = str(abs(num))  # convert to string and remove negative sign if present\n    even_count = 0\n    odd_count = 0\n    for digit in num:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game,guess):\n    return [abs(a-b) if a!=b else 0 for a,b in zip(game,guess)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if type(num) == int and num > 10:\n            str_num = str(abs(num))\n            if int(str_num[0]) % 2 != 0 and int(str_num[-1]) % 2 != 0:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "def tri(n):\n    if n == 0:\n        return [3]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        tribonacci = [1, 3, 2]\n        for _ in range(3, n + 1):\n            tribonacci.append(tribonacci[-1] + tribonacci[-2] + (1 if _ % 2 else 1 + _ // 2))\n        return tribonacci", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if i % 2 == 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 10]], "plus_fail_tests": [[6, 12]]}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i+1]\n        elif operator[i] == '-':\n            result -= operand[i+1]\n        elif operator[i] == '*':\n            result *= operand[i+1]\n        elif operator[i] == '//' or operator[i] == '**':\n            if operator[i] == '//' and operand[i+1] != 0:\n                result //= operand[i+1]\n            elif operator[i] == '**':\n                result **= operand[i+1]\n            else:\n                return \"Error: Division by zero\"\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["+", "*", "-"], [2, 3, 4, 5]]], "plus_fail_tests": [[["+", "-", "*", "//"], [5, 2, 3, 4, 7]]]}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    return result if result.isalpha() else result[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["#a@C"]], "plus_fail_tests": [["tH1s Is A t3sT!"]]}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    def count_unique_chars(word):\n        return len(set(word))\n\n    max_word = max(words, key=count_unique_chars)\n    if len(set(max_word)) == 1 and len(max_word) > 1:\n        return max(words, key=len)\n    return max_word", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["name", "enam", "game"]]], "plus_fail_tests": [[["xyz", "pqr"]]]}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    total_eaten = number + min(need, remaining)\n    remaining_carrots = remaining - (need - remaining) if need > remaining else 0\n    return [total_eaten, remaining_carrots]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 6, 10]], "plus_fail_tests": [[10, 0, 10]]}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "import hashlib\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n        ]\n    syb = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n        ]\n    roman_num = ''\n    i = 0\n    while  number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num.lower()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "def right_angle_triangle(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    \"\"\"\n    # Sort the sides in ascending order\n    sides = sorted([a, b, c])\n    \n    # A right-angled triangle has a side that is the hypotenuse (the longest side)\n    # and two other sides that are the legs (the shorter sides)\n    # The sum of the squares of the legs is equal to the square of the hypotenuse\n    # So, we check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return sides[-1]**2 == sides[0]**2 + sides[1]**2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    max_prime = max([x for x in lst if isinstance(x, int) and x > 1 and is_prime(x)])\n    return sum(int(digit) for digit in str(max_prime))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "import math\ndef special_factorial(n):\n    result = 1\n    for i in range(n, 0, -1):\n        result *= i * math.factorial(i-1)\n    return int(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n + 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}